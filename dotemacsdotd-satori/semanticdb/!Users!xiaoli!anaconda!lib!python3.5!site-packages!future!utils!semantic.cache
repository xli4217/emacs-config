;; Object utils/
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "utils/"
  :tables
  (list
    (semanticdb-table "__init__.py"
      :major-mode 'python-mode
      :tags 
        '( ("\"\"\"
A selection of cross-compatible functions for Python 2 and 3.

This module exports useful functions for 2/3 compatible code:

    * bind_method: binds functions to classes
    * ``native_str_to_bytes`` and ``bytes_to_native_str``
    * ``native_str``: always equal to the native platform string object (because
      this may be shadowed by imports from future.builtins)
    * lists: lrange(), lmap(), lzip(), lfilter()
    * iterable method compatibility:
        - iteritems, iterkeys, itervalues
        - viewitems, viewkeys, viewvalues

        These use the original method if available, otherwise they use items,
        keys, values.

    * types:

        * text_type: unicode in Python 2, str in Python 3
        * binary_type: str in Python 2, bythes in Python 3
        * string_types: basestring in Python 2, str in Python 3

    * bchr(c):
        Take an integer and make a 1-character byte string
    * bord(c)
        Take the result of indexing on a byte string and make an integer
    * tobytes(s)
        Take a text string, a byte string, or a sequence of characters taken
        from a byte string, and make a byte string.

    * raise_from()
    * raise_with_traceback()

This module also defines these decorators:

    * ``python_2_unicode_compatible``
    * ``with_metaclass``
    * ``implements_iterator``

Some of the functions in this module come from the following sources:

    * Jinja2 (BSD licensed: see
      https://github.com/mitsuhiko/jinja2/blob/master/LICENSE)
    * Pandas compatibility module pandas.compat
    * six.py by Benjamin Peterson
    * Django
\"\"\"" code nil nil [1 1603])
            ("types" include nil nil [1605 1617])
            ("sys" include nil nil [1618 1628])
            ("numbers" include nil nil [1629 1643])
            ("functools" include nil nil [1644 1660])
            ("copy" include nil nil [1661 1672])
            ("inspect" include nil nil [1673 1687])
            ("PY3" code nil nil [1690 1720])
            ("PY2" code nil nil [1721 1751])
            ("PY26" code nil nil [1752 1790])
            ("PY27" code nil nil [1791 1829])
            ("PYPY" variable nil nil [1830 1874])
            ("python_2_unicode_compatible" function
               (:documentation "
    A decorator that defines __unicode__ and __str__ methods under Python
    2. Under Python 3, this decorator is a no-op.

    To support Python 2 and 3 with a single code base, define a __str__
    method returning unicode text and apply this decorator to the class, like
    this::

    >>> from future.utils import python_2_unicode_compatible

    >>> @python_2_unicode_compatible
    ... class MyClass(object):
    ...     def __str__(self):
    ...         return u'Unicode string: \\u5b54\\u5b50'

    >>> a = MyClass()

    Then, after this import:

    >>> from future.builtins import str

    the following is ``True`` on both Python 3 and 2::

    >>> str(a) == a.encode('utf-8').decode('utf-8')
    True

    and, on a Unicode-enabled terminal with the right fonts, these both print the
    Chinese characters for Confucius::

    >>> print(a)
    >>> print(str(a))

    The implementation comes from django.utils.encoding.
    "
                :arguments 
                  ( ("cls" variable nil (reparse-symbol function_parameters) [1909 1912]))                  )
                nil [1877 3005])
            ("with_metaclass" function
               (:documentation "
    Function from jinja2/_compat.py. License: BSD.

    Use it like this::

        class BaseForm(object):
            pass

        class FormType(type):
            pass

        class Form(with_metaclass(FormType, BaseForm)):
            pass

    This requires a bit of explanation: the basic idea is to make a
    dummy metaclass for one level of class instantiation that replaces
    itself with the actual metaclass.  Because of internal type checks
    we also need to make sure that we downgrade the custom metaclass
    for one level to something closer to type (that's why __call__ and
    __init__ comes back from type etc.).

    This has the advantage over six.with_metaclass of not introducing
    dummy classes into the final MRO.
    "
                :arguments 
                  ( ("meta" variable nil (reparse-symbol function_parameters) [3026 3030])
                    ("bases" variable nil (reparse-symbol function_parameters) [3032 3038]))                  )
                nil [3007 4124])
            ("if" code nil nil [4178 4801])
            ("if" code nil nil [4807 5190])
            ("tobytes" variable nil nil [5191 5298])
            ("if" code nil nil [5300 6016])
            ("native_str_to_bytes" variable nil nil [6017 6170])
            ("if" code nil nil [6172 6746])
            ("isidentifier" function (:arguments 
              ( ("s" variable nil (reparse-symbol function_parameters) [6765 6766])
                ("dotted" variable nil (reparse-symbol function_parameters) [6768 6774]))              ) nil [6748 7105])
            ("viewitems" function
               (:documentation "
    Function for iterating over dictionary items with the same set-like
    behaviour on Py2.7 as on Py3.

    Passes kwargs to method."
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [7121 7124])
                    ("kwargs" variable nil (reparse-symbol function_parameters) [7126 7134]))                  )
                nil [7107 7395])
            ("viewkeys" function
               (:documentation "
    Function for iterating over dictionary keys with the same set-like
    behaviour on Py2.7 as on Py3.

    Passes kwargs to method."
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [7410 7413])
                    ("kwargs" variable nil (reparse-symbol function_parameters) [7415 7423]))                  )
                nil [7397 7681])
            ("viewvalues" function
               (:documentation "
    Function for iterating over dictionary values with the same set-like
    behaviour on Py2.7 as on Py3.

    Passes kwargs to method."
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [7698 7701])
                    ("kwargs" variable nil (reparse-symbol function_parameters) [7703 7711]))                  )
                nil [7683 7975])
            ("iteritems" function
               (:documentation "Use this only if compatibility with Python versions before 2.7 is
    required. Otherwise, prefer viewitems().
    "
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [7991 7994])
                    ("kwargs" variable nil (reparse-symbol function_parameters) [7996 8004]))                  )
                nil [7977 8244])
            ("iterkeys" function
               (:documentation "Use this only if compatibility with Python versions before 2.7 is
    required. Otherwise, prefer viewkeys().
    "
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [8259 8262])
                    ("kwargs" variable nil (reparse-symbol function_parameters) [8264 8272]))                  )
                nil [8246 8509])
            ("itervalues" function
               (:documentation "Use this only if compatibility with Python versions before 2.7 is
    required. Otherwise, prefer viewvalues().
    "
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [8526 8529])
                    ("kwargs" variable nil (reparse-symbol function_parameters) [8531 8539]))                  )
                nil [8511 8782])
            ("bind_method" function
               (:documentation "Bind a method to class, python 2 and python 3 compatible.

    Parameters
    ----------

    cls : type
        class to receive bound method
    name : basestring
        name of method on class instance
    func : function
        function to be bound as method

    Returns
    -------
    None
    "
                :arguments 
                  ( ("cls" variable nil (reparse-symbol function_parameters) [8800 8803])
                    ("name" variable nil (reparse-symbol function_parameters) [8805 8809])
                    ("func" variable nil (reparse-symbol function_parameters) [8811 8815]))                  )
                nil [8784 9313])
            ("getexception" function nil nil [9315 9364])
            ("_get_caller_globals_and_locals" function (:documentation "
    Returns the globals and locals of the calling frame.

    Is there an alternative to frame hacking here?
    ") nil [9366 9680])
            ("_repr_strip" function
               (:documentation "
    Returns the string without any initial or final quotes.
    "
                :arguments 
                  ( ("mystring" variable nil (reparse-symbol function_parameters) [9698 9706]))                  )
                nil [9682 9904])
            ("if" code nil nil [9906 12780])
            ("raise_with_traceback" variable nil nil [12782 12929])
            ("reraise" variable nil nil [13011 13027])
            ("implements_iterator" function (:arguments 
              ( ("cls" variable nil (reparse-symbol function_parameters) [13054 13057]))              ) nil [13030 13571])
            ("if" code nil nil [13572 13654])
            ("encode_filename" function (:arguments 
              ( ("filename" variable nil (reparse-symbol function_parameters) [13676 13684]))              ) nil [13656 13843])
            ("is_new_style" function
               (:documentation "
    Python 2.7 has both new-style and old-style classes. Old-style classes can
    be pesky in some circumstances, such as when using inheritance.  Use this
    function to test for whether a class is new-style. (Python 3 only has
    new-style classes.)
    "
                :arguments 
                  ( ("cls" variable nil (reparse-symbol function_parameters) [13862 13865]))                  )
                nil [13845 14276])
            ("native_str" variable nil nil [14421 14437])
            ("native_bytes" variable nil nil [14438 14458])
            ("istext" function
               (:documentation "
    Deprecated. Use::
        >>> isinstance(obj, str)
    after this import:
        >>> from future.builtins import str
    "
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [14472 14475]))                  )
                nil [14461 14654])
            ("isbytes" function
               (:documentation "
    Deprecated. Use::
        >>> isinstance(obj, bytes)
    after this import:
        >>> from future.builtins import bytes
    "
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [14668 14671]))                  )
                nil [14656 14854])
            ("isnewbytes" function
               (:documentation "
    Equivalent to the result of ``isinstance(obj, newbytes)`` were
    ``__instancecheck__`` not overridden on the newbytes subclass. In
    other words, it is REALLY a newbytes instance, not a Py2 native str
    object?
    "
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [14871 14874]))                  )
                nil [14856 15315])
            ("isint" function
               (:documentation "
    Deprecated. Tests whether an object is a Py3 ``int`` or either a Py2 ``int`` or
    ``long``.

    Instead of using this function, you can use:

        >>> from future.builtins import int
        >>> isinstance(obj, int)

    The following idiom is equivalent:

        >>> from numbers import Integral
        >>> isinstance(obj, Integral)
    "
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [15327 15330]))                  )
                nil [15317 15741])
            ("native" function
               (:documentation "
    On Py3, this is a no-op: native(obj) -> obj

    On Py2, returns the corresponding native Py2 types that are
    superclasses for backported objects from Py3:

    >>> from builtins import str, bytes, int

    >>> native(str(u'ABC'))
    u'ABC'
    >>> type(native(str(u'ABC')))
    unicode

    >>> native(bytes(b'ABC'))
    b'ABC'
    >>> type(native(bytes(b'ABC')))
    bytes

    >>> native(int(10**20))
    100000000000000000000L
    >>> type(native(int(10**20)))
    long

    Existing native types on Py2 will be returned unchanged:

    >>> type(native(u'ABC'))
    unicode
    "
                :arguments 
                  ( ("obj" variable nil (reparse-symbol function_parameters) [15754 15757]))                  )
                nil [15743 16458])
            ("if" code nil nil [16503 16947])
            ("old_div" function
               (:documentation "
    DEPRECATED: import ``old_div`` from ``past.utils`` instead.

    Equivalent to ``a / b`` on Python 2 without ``from __future__ import
    division``.

    TODO: generalize this to other objects (like arrays etc.)
    "
                :arguments 
                  ( ("a" variable nil (reparse-symbol function_parameters) [17004 17005])
                    ("b" variable nil (reparse-symbol function_parameters) [17007 17008]))                  )
                nil [16992 17373])
            ("as_native_str" function (:arguments 
              ( ("encoding" variable nil (reparse-symbol function_parameters) [17393 17401]))              ) nil [17375 18070])
            ("try" code nil nil [18153 18440])
            ("if" code nil nil [18441 19465])
            ("__all__" variable nil nil [19467 20238]))          
      :file "__init__.py"
      :pointmax 20239
      :fsize 20238
      :lastmodtime '(22546 24082 0 0)
      :unmatched-syntax nil))
  :file "!Users!xiaoli!anaconda!lib!python3.5!site-packages!future!utils!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
