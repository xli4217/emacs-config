;; Object semanticdb-project-database-file
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "semanticdb-project-database-file"
  :tables
  (list
    (semanticdb-table "semanticdb-table"
      :major-mode python-mode
      :tags 
        '( ("numpy" include nil nil [1 19])
            ("torch" include nil nil [20 32])
            ("time" include nil nil [33 44])
            ("nuscenes.prediction.helper" include nil nil [45 101])
            ("nuscenes.eval.common.utils" include nil nil [102 155])
            ("pyquaternion" include nil nil [156 191])
            ("typing" include nil nil [192 232])
            ("importlib" include nil nil [233 249])
            ("IPython" include nil nil [252 297])
            ("pyvirtualdisplay" include nil nil [298 334])
            ("pathlib" include nil nil [335 359])
            ("base64" include nil nil [360 373])
            ("celluloid" include nil nil [374 402])
            ("display" variable nil nil [404 450])
            ("display" code nil nil [451 466])
            ("show_video_in_jupyter" function (:arguments 
              ( ("path" variable nil (reparse-symbol function_parameters) [3123 3127]))              ) nil [3097 3571])
            ("generate_video_from_images" function
               (:parent "dummy"
                :arguments 
                  ( ("self" variable nil (reparse-symbol function_parameters) [3604 3608])
                    ("str" variable nil (reparse-symbol function_parameters) [3619 3622])
                    ("str" variable nil (reparse-symbol function_parameters) [3640 3643]))                  )
                nil [3573 4259])
            ("timeit" function (:arguments 
              ( ("method" variable nil (reparse-symbol function_parameters) [4473 4479]))              ) nil [4462 4891])
            ("Maxish" type
               (:superclasses ("torch.nn.Module")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("super" code nil (reparse-symbol indented_block_body) [4981 5011])
                            ("self" variable nil (reparse-symbol indented_block_body) [5020 5042]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [4945 4949])
                            ("name" variable nil (reparse-symbol function_parameters) [4951 4955]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [4932 5043])
                    ("forward" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [5060 5064])
                            ("x" variable nil (reparse-symbol function_parameters) [5066 5067])
                            ("scale" variable nil (reparse-symbol function_parameters) [5069 5074])
                            ("dim" variable nil (reparse-symbol function_parameters) [5076 5079])
                            ("keepdim" variable nil (reparse-symbol function_parameters) [5083 5090]))                          )
                        (reparse-symbol indented_block_body) [5048 5476]))                  
                :type "class")
                nil [4897 5476])
            ("Minish" type
               (:superclasses ("torch.nn.Module")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("super" code nil (reparse-symbol indented_block_body) [5561 5591])
                            ("self" variable nil (reparse-symbol indented_block_body) [5600 5622]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [5525 5529])
                            ("name" variable nil (reparse-symbol function_parameters) [5531 5535]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [5512 5623])
                    ("forward" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [5640 5644])
                            ("x" variable nil (reparse-symbol function_parameters) [5646 5647])
                            ("scale" variable nil (reparse-symbol function_parameters) [5649 5654])
                            ("dim" variable nil (reparse-symbol function_parameters) [5656 5659])
                            ("keepdim" variable nil (reparse-symbol function_parameters) [5663 5670]))                          )
                        (reparse-symbol indented_block_body) [5628 6057]))                  
                :type "class")
                nil [5477 6057])
            ("assert_type" function (:arguments 
              ( ("x" variable nil (reparse-symbol function_parameters) [6075 6076])
                ("name" variable nil (reparse-symbol function_parameters) [6078 6082])
                ("expected_type" variable nil (reparse-symbol function_parameters) [6084 6097]))              ) nil [6059 6181])
            ("assert_shape" function (:arguments 
              ( ("x" variable nil (reparse-symbol function_parameters) [6207 6208])
                ("name" variable nil (reparse-symbol function_parameters) [6210 6214])
                ("expected_shape" variable nil (reparse-symbol function_parameters) [6216 6230]))              ) nil [6190 6646])
            ("assert_type_and_shape" function (:arguments 
              ( ("x" variable nil (reparse-symbol function_parameters) [7163 7164])
                ("name" variable nil (reparse-symbol function_parameters) [7166 7170])
                ("expected_type" variable nil (reparse-symbol function_parameters) [7172 7185])
                ("expected_shape" variable nil (reparse-symbol function_parameters) [7187 7201]))              ) nil [7137 7297])
            ("distance_from_point_to_discretized_lane" function (:arguments 
              ( ("Tensor" variable nil (reparse-symbol function_parameters) [7360 7366])
                ("Tensor" variable nil (reparse-symbol function_parameters) [7380 7386]))              ) nil [7298 7932])
            ("batch_distance_from_trajectory_to_discretized_lanes" function (:arguments 
              ( ("Tensor" variable nil (reparse-symbol function_parameters) [8007 8013])
                ("Tensor" variable nil (reparse-symbol function_parameters) [8033 8039]))              ) nil [7933 9190])
            ("distance_from_point_to_quadratic_curve" function (:arguments 
              ( ("Tensor" variable nil (reparse-symbol function_parameters) [9250 9256])
                ("Tensor" variable nil (reparse-symbol function_parameters) [9270 9276]))              ) nil [9195 10485])
            ("split_list_for_multi_worker" function (:arguments 
              ( ("list" variable nil (reparse-symbol function_parameters) [10533 10537])
                ("int" variable nil (reparse-symbol function_parameters) [10550 10553]))              ) nil [10490 11003])
            ("timing_val" function (:arguments 
              ( ("func" variable nil (reparse-symbol function_parameters) [11019 11023]))              ) nil [11004 11266])
            ("get_distance" function (:arguments 
              ( ("ndarray" variable nil (reparse-symbol function_parameters) [11303 11310])
                ("ndarray" variable nil (reparse-symbol function_parameters) [11328 11335]))              ) nil [11271 12741])
            ("set_function_arguments_decorator" function (:arguments 
              ( ("config" variable nil (reparse-symbol function_parameters) [12780 12786]))              ) nil [12743 13505])
            ("set_function_arguments_for_class" function (:arguments 
              ( ("Cls" variable nil (reparse-symbol function_parameters) [13543 13546]))              ) nil [13506 13659])
            ("set_function_arguments" function (:arguments 
              ( ("dict" variable nil (reparse-symbol function_parameters) [13706 13710])
                ("dict" variable nil (reparse-symbol function_parameters) [13725 13729]))              ) nil [13665 14170])
            ("log_data" function (:arguments 
              ( ("dict" variable nil (reparse-symbol function_parameters) [14195 14199])
                ("py_logger" variable nil (reparse-symbol function_parameters) [14204 14213])
                ("tb_logger" variable nil (reparse-symbol function_parameters) [14220 14229]))              ) nil [14171 15200])
            ("translate_mesh2D" function (:arguments 
              ( ("pos" variable nil (reparse-symbol function_parameters) [15222 15225])
                ("X" variable nil (reparse-symbol function_parameters) [15227 15228])
                ("Y" variable nil (reparse-symbol function_parameters) [15230 15231]))              ) nil [15201 15268])
            ("rotate_mesh2D" function (:arguments 
              ( ("pos" variable nil (reparse-symbol function_parameters) [15287 15290])
                ("rot_rad" variable nil (reparse-symbol function_parameters) [15292 15299])
                ("X" variable nil (reparse-symbol function_parameters) [15301 15302])
                ("Y" variable nil (reparse-symbol function_parameters) [15304 15305])
                ("frame" variable nil (reparse-symbol function_parameters) [15307 15312]))              ) nil [15269 15741])
            ("transform_mesh2D" function (:arguments 
              ( ("pos" variable nil (reparse-symbol function_parameters) [15767 15770])
                ("rot_rad" variable nil (reparse-symbol function_parameters) [15772 15779])
                ("X" variable nil (reparse-symbol function_parameters) [15781 15782])
                ("Y" variable nil (reparse-symbol function_parameters) [15784 15785]))              ) nil [15746 15928])
            ("if" code nil nil [15951 16032]))          
      :file "utils.py"
      :pointmax 16032
      :fsize 16031
      :lastmodtime '(24684 61625 957967 203000)
      :unmatched-syntax '((NAME 14184 . 14193) (COLON 14193 . 14194) (NAME 13717 . 13723) (COLON 13723 . 13724) (NAME 13692 . 13705) (COLON 13705 . 13706) (PERIOD 11327 . 11328) (NAME 11312 . 11324) (COLON 11324 . 11325) (PERIOD 11302 . 11303) (NAME 11288 . 11299) (COLON 11299 . 11300) (NAME 10539 . 10549) (COLON 10549 . 10550) (NAME 10522 . 10532) (COLON 10532 . 10533) (PERIOD 9269 . 9270) (NAME 9258 . 9263) (COLON 9263 . 9264) (PERIOD 9249 . 9250) (NAME 9238 . 9243) (COLON 9243 . 9244) (PERIOD 8032 . 8033) (NAME 8015 . 8025) (COLON 8025 . 8026) (PERIOD 8006 . 8007) (NAME 7989 . 7999) (COLON 7999 . 8000) (PERIOD 7379 . 7380) (NAME 7368 . 7373) (COLON 7373 . 7374) (PERIOD 7359 . 7360) (NAME 7342 . 7352) (COLON 7352 . 7353) (INDENT_BLOCK 4309 . 4460) (COLON 4307 . 4308) (DEF 4265 . 4268) (MINUS 4296 . 4297) (GT 4297 . 4298) (NAME 4285 . 4289) (COLON 4289 . 4290) (NAME 3624 . 3639) (COLON 3639 . 3640) (NAME 3610 . 3618) (COLON 3618 . 3619) (INDENT_BLOCK 2435 . 3095) (COLON 2433 . 2434) (MINUS 2420 . 2421) (GT 2421 . 2422) (BRACK_BLOCK 2390 . 2418) (COLON 2383 . 2384) (COMMA 2338 . 2339) (BRACK_BLOCK 2317 . 2338) (NAME 2299 . 2310) (COLON 2310 . 2311) (PERIOD 2254 . 2255) (NAME 2239 . 2250) (COLON 2250 . 2251) (INDENT_BLOCK 1379 . 2202) (COLON 1377 . 1378) (MINUS 1364 . 1365) (GT 1365 . 1366) (BRACK_BLOCK 1334 . 1362) (COLON 1327 . 1328) (COMMA 1282 . 1283) (BRACK_BLOCK 1261 . 1282) (NAME 1243 . 1254) (COLON 1254 . 1255) (PERIOD 1198 . 1199) (NAME 1183 . 1194) (COLON 1194 . 1195) (INDENT_BLOCK 880 . 1146) (COLON 878 . 879) (MINUS 865 . 866) (GT 866 . 867) (NAME 840 . 856) (COLON 856 . 857) (INDENT_BLOCK 512 . 810) (COLON 510 . 511) (DEF 468 . 471) (MINUS 502 . 503) (GT 503 . 504) (NAME 490 . 493) (COLON 493 . 494) (NAME 14212 . 14221) (COLON 14221 . 14222) (NAME 13745 . 13751) (COLON 13751 . 13752) (NAME 13720 . 13733) (COLON 13733 . 13734) (PERIOD 11355 . 11356) (NAME 11340 . 11352) (COLON 11352 . 11353) (PERIOD 11330 . 11331) (NAME 11316 . 11327) (COLON 11327 . 11328) (NAME 10567 . 10577) (COLON 10577 . 10578) (NAME 10550 . 10560) (COLON 10560 . 10561) (PERIOD 9297 . 9298) (NAME 9286 . 9291) (COLON 9291 . 9292) (PERIOD 9277 . 9278) (NAME 9266 . 9271) (COLON 9271 . 9272) (PERIOD 8060 . 8061) (NAME 8043 . 8053) (COLON 8053 . 8054) (PERIOD 8034 . 8035) (NAME 8017 . 8027) (COLON 8027 . 8028) (PERIOD 7407 . 7408) (NAME 7396 . 7401) (COLON 7401 . 7402) (PERIOD 7387 . 7388) (NAME 7370 . 7380) (COLON 7380 . 7381) (INDENT_BLOCK 4337 . 4488) (COLON 4335 . 4336) (DEF 4293 . 4296) (MINUS 4324 . 4325) (GT 4325 . 4326) (NAME 4313 . 4317) (COLON 4317 . 4318) (NAME 3652 . 3667) (COLON 3667 . 3668) (NAME 3638 . 3646) (COLON 3646 . 3647) (INDENT_BLOCK 2463 . 3123) (COLON 2461 . 2462) (MINUS 2448 . 2449) (GT 2449 . 2450) (BRACK_BLOCK 2418 . 2446) (COLON 2411 . 2412) (COMMA 2366 . 2367) (BRACK_BLOCK 2345 . 2366) (NAME 2327 . 2338) (COLON 2338 . 2339) (PERIOD 2282 . 2283) (NAME 2267 . 2278) (COLON 2278 . 2279) (INDENT_BLOCK 1407 . 2230) (COLON 1405 . 1406) (MINUS 1392 . 1393) (GT 1393 . 1394) (BRACK_BLOCK 1362 . 1390) (COLON 1355 . 1356) (COMMA 1310 . 1311) (BRACK_BLOCK 1289 . 1310) (NAME 1271 . 1282) (COLON 1282 . 1283) (PERIOD 1226 . 1227) (NAME 1211 . 1222) (COLON 1222 . 1223) (INDENT_BLOCK 908 . 1174) (COLON 906 . 907) (MINUS 893 . 894) (GT 894 . 895) (NAME 868 . 884) (COLON 884 . 885) (INDENT_BLOCK 540 . 838) (COLON 538 . 539) (DEF 496 . 499) (MINUS 530 . 531) (GT 531 . 532) (NAME 518 . 521) (COLON 521 . 522)))
    (semanticdb-table "semanticdb-table"
      :major-mode python-mode
      :tags 
        '( ("\"\"\"Homogeneous Transformation Matrices and Quaternions.

A library for calculating 4x4 matrices for translating, rotating, reflecting,
scaling, shearing, projecting, orthogonalizing, and superimposing arrays of
3D homogeneous coordinates as well as for converting between rotation matrices,
Euler angles, and quaternions. Also includes an Arcball control object and
functions to decompose transformation matrices.

:Authors:
  `Christoph Gohlke <http://www.lfd.uci.edu/~gohlke/>`__,
  Laboratory for Fluorescence Dynamics, University of California, Irvine

:Version: 20090418

Requirements
------------

* `Python 2.6 <http://www.python.org>`__
* `Numpy 1.3 <http://numpy.scipy.org>`__
* `transformations.c 20090418 <http://www.lfd.uci.edu/~gohlke/>`__
  (optional implementation of some functions in C)

Notes
-----

Matrices (M) can be inverted using numpy.linalg.inv(M), concatenated using
numpy.dot(M0, M1), or used to transform homogeneous coordinates (v) using
numpy.dot(M, v) for shape (4, \\*) \"point of arrays\", respectively
numpy.dot(v, M.T) for shape (\\*, 4) \"array of points\".

Calculations are carried out with numpy.float64 precision.

This Python implementation is not optimized for speed.

Vector, point, quaternion, and matrix function arguments are expected to be
\"array like\", i.e. tuple, list, or numpy arrays.

Return types are numpy arrays unless specified otherwise.

Angles are in radians unless specified otherwise.

Quaternions ix+jy+kz+w are represented as [x, y, z, w].

Use the transpose of transformation matrices for OpenGL glMultMatrixd().

A triple of Euler angles can be applied/interpreted in 24 ways, which can
be specified using a 4 character string or encoded 4-tuple:

  *Axes 4-string*: e.g. 'sxyz' or 'ryxy'

  - first character : rotations are applied to 's'tatic or 'r'otating frame
  - remaining characters : successive rotation axis 'x', 'y', or 'z'

  *Axes 4-tuple*: e.g. (0, 0, 0, 0) or (1, 1, 1, 1)

  - inner axis: code of axis ('x':0, 'y':1, 'z':2) of rightmost matrix.
  - parity : even (0) if inner axis 'x' is followed by 'y', 'y' is followed
    by 'z', or 'z' is followed by 'x'. Otherwise odd (1).
  - repetition : first and last axis are same (1) or different (0).
  - frame : rotations are applied to static (0) or rotating (1) frame.

References
----------

(1)  Matrices and transformations. Ronald Goldman.
     In \"Graphics Gems I\", pp 472-475. Morgan Kaufmann, 1990.
(2)  More matrices and transformations: shear and pseudo-perspective.
     Ronald Goldman. In \"Graphics Gems II\", pp 320-323. Morgan Kaufmann, 1991.
(3)  Decomposing a matrix into simple transformations. Spencer Thomas.
     In \"Graphics Gems II\", pp 320-323. Morgan Kaufmann, 1991.
(4)  Recovering the data from the transformation matrix. Ronald Goldman.
     In \"Graphics Gems II\", pp 324-331. Morgan Kaufmann, 1991.
(5)  Euler angle conversion. Ken Shoemake.
     In \"Graphics Gems IV\", pp 222-229. Morgan Kaufmann, 1994.
(6)  Arcball rotation control. Ken Shoemake.
     In \"Graphics Gems IV\", pp 175-192. Morgan Kaufmann, 1994.
(7)  Representing attitude: Euler angles, unit quaternions, and rotation
     vectors. James Diebel. 2006.
(8)  A discussion of the solution for the best rotation to relate two sets
     of vectors. W Kabsch. Acta Cryst. 1978. A34, 827-828.
(9)  Closed-form solution of absolute orientation using unit quaternions.
     BKP Horn. J Opt Soc Am A. 1987. 4(4), 629-642.
(10) Quaternions. Ken Shoemake.
     http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf
(11) From quaternion to matrix and back. JMP van Waveren. 2005.
     http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm
(12) Uniform random rotations. Ken Shoemake.
     In \"Graphics Gems III\", pp 124-132. Morgan Kaufmann, 1992.


Examples
--------

>>> alpha, beta, gamma = 0.123, -1.234, 2.345
>>> origin, xaxis, yaxis, zaxis = (0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)
>>> I = identity_matrix()
>>> Rx = rotation_matrix(alpha, xaxis)
>>> Ry = rotation_matrix(beta, yaxis)
>>> Rz = rotation_matrix(gamma, zaxis)
>>> R = concatenate_matrices(Rx, Ry, Rz)
>>> euler = euler_from_matrix(R, 'rxyz')
>>> numpy.allclose([alpha, beta, gamma], euler)
True
>>> Re = euler_matrix(alpha, beta, gamma, 'rxyz')
>>> is_same_transform(R, Re)
True
>>> al, be, ga = euler_from_matrix(Re, 'rxyz')
>>> is_same_transform(Re, euler_matrix(al, be, ga, 'rxyz'))
True
>>> qx = quaternion_about_axis(alpha, xaxis)
>>> qy = quaternion_about_axis(beta, yaxis)
>>> qz = quaternion_about_axis(gamma, zaxis)
>>> q = quaternion_multiply(qx, qy)
>>> q = quaternion_multiply(q, qz)
>>> Rq = quaternion_matrix(q)
>>> is_same_transform(R, Rq)
True
>>> S = scale_matrix(1.23, origin)
>>> T = translation_matrix((1, 2, 3))
>>> Z = shear_matrix(beta, xaxis, origin, zaxis)
>>> R = random_rotation_matrix(numpy.random.rand(3))
>>> M = concatenate_matrices(T, R, Z, S)
>>> scale, shear, angles, trans, persp = decompose_matrix(M)
>>> numpy.allclose(scale, 1.23)
True
>>> numpy.allclose(trans, (1, 2, 3))
True
>>> numpy.allclose(shear, (0, math.tan(beta), 0))
True
>>> is_same_transform(R, euler_matrix(axes='sxyz', *angles))
True
>>> M1 = compose_matrix(scale, shear, angles, trans, persp)
>>> is_same_transform(M, M1)
True

\"\"\"" code nil nil [1661 6877])
            ("__future__" include nil nil [6879 6910])
            ("warnings" include nil nil [6912 6927])
            ("math" include nil nil [6928 6939])
            ("numpy" include nil nil [6941 6953])
            ("__docformat__" variable nil nil [7015 7052])
            ("identity_matrix" function (:documentation "Return 4x4 identity/unit matrix.

    >>> I = identity_matrix()
    >>> numpy.allclose(I, numpy.dot(I, I))
    True
    >>> numpy.sum(I), numpy.trace(I)
    (4.0, 4.0)
    >>> numpy.allclose(I, numpy.identity(4, dtype=numpy.float64))
    True

    ") nil [7055 7387])
            ("translation_matrix" function
               (:documentation "Return matrix to translate by direction vector.

    >>> v = numpy.random.random(3) - 0.5
    >>> numpy.allclose(v, translation_matrix(v)[:3, 3])
    True

    "
                :arguments 
                  ( ("direction" variable nil (reparse-symbol function_parameters) [7412 7421]))                  )
                nil [7389 7663])
            ("translation_from_matrix" function
               (:documentation "Return translation vector from translation matrix.

    >>> v0 = numpy.random.random(3) - 0.5
    >>> v1 = translation_from_matrix(translation_matrix(v0))
    >>> numpy.allclose(v0, v1)
    True

    "
                :arguments 
                  ( ("matrix" variable nil (reparse-symbol function_parameters) [7693 7699]))                  )
                nil [7665 7970])
            ("reflection_matrix" function
               (:documentation "Return matrix to mirror at plane defined by point and normal vector.

    >>> v0 = numpy.random.random(4) - 0.5
    >>> v0[3] = 1.0
    >>> v1 = numpy.random.random(3) - 0.5
    >>> R = reflection_matrix(v0, v1)
    >>> numpy.allclose(2., numpy.trace(R))
    True
    >>> numpy.allclose(v0, numpy.dot(R, v0))
    True
    >>> v2 = v0.copy()
    >>> v2[:3] += v1
    >>> v3 = v0.copy()
    >>> v2[:3] -= v1
    >>> numpy.allclose(v2, numpy.dot(R, v3))
    True

    "
                :arguments 
                  ( ("point" variable nil (reparse-symbol function_parameters) [7994 7999])
                    ("normal" variable nil (reparse-symbol function_parameters) [8001 8007]))                  )
                nil [7972 8674])
            ("reflection_from_matrix" function
               (:documentation "Return mirror plane point and normal vector from reflection matrix.

    >>> v0 = numpy.random.random(3) - 0.5
    >>> v1 = numpy.random.random(3) - 0.5
    >>> M0 = reflection_matrix(v0, v1)
    >>> point, normal = reflection_from_matrix(M0)
    >>> M1 = reflection_matrix(point, normal)
    >>> is_same_transform(M0, M1)
    True

    "
                :arguments 
                  ( ("matrix" variable nil (reparse-symbol function_parameters) [8703 8709]))                  )
                nil [8676 9763])
            ("rotation_matrix" function
               (:documentation "Return matrix to rotate about axis defined by point and direction.

    >>> angle = (random.random() - 0.5) * (2*math.pi)
    >>> direc = numpy.random.random(3) - 0.5
    >>> point = numpy.random.random(3) - 0.5
    >>> R0 = rotation_matrix(angle, direc, point)
    >>> R1 = rotation_matrix(angle-2*math.pi, direc, point)
    >>> is_same_transform(R0, R1)
    True
    >>> R0 = rotation_matrix(angle, direc, point)
    >>> R1 = rotation_matrix(-angle, -direc, point)
    >>> is_same_transform(R0, R1)
    True
    >>> I = numpy.identity(4, numpy.float64)
    >>> numpy.allclose(I, rotation_matrix(math.pi*2, direc))
    True
    >>> numpy.allclose(2., numpy.trace(rotation_matrix(math.pi/2,
    ...                                                direc, point)))
    True

    "
                :arguments 
                  ( ("angle" variable nil (reparse-symbol function_parameters) [9785 9790])
                    ("direction" variable nil (reparse-symbol function_parameters) [9792 9801])
                    ("point" variable nil (reparse-symbol function_parameters) [9803 9808]))                  )
                nil [9765 11441])
            ("rotation_from_matrix" function
               (:documentation "Return rotation angle and axis from rotation matrix.

    >>> angle = (random.random() - 0.5) * (2*math.pi)
    >>> direc = numpy.random.random(3) - 0.5
    >>> point = numpy.random.random(3) - 0.5
    >>> R0 = rotation_matrix(angle, direc, point)
    >>> angle, direc, point = rotation_from_matrix(R0)
    >>> R1 = rotation_matrix(angle, direc, point)
    >>> is_same_transform(R0, R1)
    True

    "
                :arguments 
                  ( ("matrix" variable nil (reparse-symbol function_parameters) [11468 11474]))                  )
                nil [11443 13075])
            ("scale_matrix" function
               (:documentation "Return matrix to scale by factor around origin in direction.

    Use factor -1 for point symmetry.

    >>> v = (numpy.random.rand(4, 5) - 0.5) * 20.0
    >>> v[3] = 1.0
    >>> S = scale_matrix(-1.234)
    >>> numpy.allclose(numpy.dot(S, v)[:3], -1.234*v[:3])
    True
    >>> factor = random.random() * 10 - 5
    >>> origin = numpy.random.random(3) - 0.5
    >>> direct = numpy.random.random(3) - 0.5
    >>> S = scale_matrix(factor, origin)
    >>> S = scale_matrix(factor, origin, direct)

    "
                :arguments 
                  ( ("factor" variable nil (reparse-symbol function_parameters) [13094 13100])
                    ("origin" variable nil (reparse-symbol function_parameters) [13102 13108])
                    ("direction" variable nil (reparse-symbol function_parameters) [13115 13124]))                  )
                nil [13077 14376])
            ("scale_from_matrix" function
               (:documentation "Return scaling factor, origin and direction from scaling matrix.

    >>> factor = random.random() * 10 - 5
    >>> origin = numpy.random.random(3) - 0.5
    >>> direct = numpy.random.random(3) - 0.5
    >>> S0 = scale_matrix(factor, origin)
    >>> factor, origin, direction = scale_from_matrix(S0)
    >>> S1 = scale_matrix(factor, origin, direction)
    >>> is_same_transform(S0, S1)
    True
    >>> S0 = scale_matrix(factor, origin, direct)
    >>> factor, origin, direction = scale_from_matrix(S0)
    >>> S1 = scale_matrix(factor, origin, direction)
    >>> is_same_transform(S0, S1)
    True

    "
                :arguments 
                  ( ("matrix" variable nil (reparse-symbol function_parameters) [14400 14406]))                  )
                nil [14378 15880])
            ("projection_matrix" function
               (:documentation "Return matrix to project onto plane defined by point and normal.

    Using either perspective point, projection direction, or none of both.

    If pseudo is True, perspective projections will preserve relative depth
    such that Perspective = dot(Orthogonal, PseudoPerspective).

    >>> P = projection_matrix((0, 0, 0), (1, 0, 0))
    >>> numpy.allclose(P[1:, 1:], numpy.identity(4)[1:, 1:])
    True
    >>> point = numpy.random.random(3) - 0.5
    >>> normal = numpy.random.random(3) - 0.5
    >>> direct = numpy.random.random(3) - 0.5
    >>> persp = numpy.random.random(3) - 0.5
    >>> P0 = projection_matrix(point, normal)
    >>> P1 = projection_matrix(point, normal, direction=direct)
    >>> P2 = projection_matrix(point, normal, perspective=persp)
    >>> P3 = projection_matrix(point, normal, perspective=persp, pseudo=True)
    >>> is_same_transform(P2, numpy.dot(P0, P3))
    True
    >>> P = projection_matrix((3, 0, 0), (1, 1, 0), (1, 0, 0))
    >>> v0 = (numpy.random.rand(4, 5) - 0.5) * 20.0
    >>> v0[3] = 1.0
    >>> v1 = numpy.dot(P, v0)
    >>> numpy.allclose(v1[1], v0[1])
    True
    >>> numpy.allclose(v1[0], 3.0-v1[1])
    True

    "
                :arguments 
                  ( ("point" variable nil (reparse-symbol function_parameters) [15904 15909])
                    ("normal" variable nil (reparse-symbol function_parameters) [15911 15917])
                    ("direction" variable nil (reparse-symbol function_parameters) [15919 15928])
                    ("perspective" variable nil (reparse-symbol function_parameters) [15957 15968])
                    ("pseudo" variable nil (reparse-symbol function_parameters) [15975 15981]))                  )
                nil [15882 18411])
            ("projection_from_matrix" function
               (:documentation "Return projection plane and perspective point from projection matrix.

    Return values are same as arguments for projection_matrix function:
    point, normal, direction, perspective, and pseudo.

    >>> point = numpy.random.random(3) - 0.5
    >>> normal = numpy.random.random(3) - 0.5
    >>> direct = numpy.random.random(3) - 0.5
    >>> persp = numpy.random.random(3) - 0.5
    >>> P0 = projection_matrix(point, normal)
    >>> result = projection_from_matrix(P0)
    >>> P1 = projection_matrix(*result)
    >>> is_same_transform(P0, P1)
    True
    >>> P0 = projection_matrix(point, normal, direct)
    >>> result = projection_from_matrix(P0)
    >>> P1 = projection_matrix(*result)
    >>> is_same_transform(P0, P1)
    True
    >>> P0 = projection_matrix(point, normal, perspective=persp, pseudo=False)
    >>> result = projection_from_matrix(P0, pseudo=False)
    >>> P1 = projection_matrix(*result)
    >>> is_same_transform(P0, P1)
    True
    >>> P0 = projection_matrix(point, normal, perspective=persp, pseudo=True)
    >>> result = projection_from_matrix(P0, pseudo=True)
    >>> P1 = projection_matrix(*result)
    >>> is_same_transform(P0, P1)
    True

    "
                :arguments 
                  ( ("matrix" variable nil (reparse-symbol function_parameters) [18440 18446])
                    ("pseudo" variable nil (reparse-symbol function_parameters) [18448 18454]))                  )
                nil [18413 21354])
            ("clip_matrix" function
               (:documentation "Return matrix to obtain normalized device coordinates from frustrum.

    The frustrum bounds are axis-aligned along x (left, right),
    y (bottom, top) and z (near, far).

    Normalized device coordinates are in range [-1, 1] if coordinates are
    inside the frustrum.

    If perspective is True the frustrum is a truncated pyramid with the
    perspective point at origin and direction along z axis, otherwise an
    orthographic canonical view volume (a box).

    Homogeneous coordinates transformed by the perspective clip matrix
    need to be dehomogenized (devided by w coordinate).

    >>> frustrum = numpy.random.rand(6)
    >>> frustrum[1] += frustrum[0]
    >>> frustrum[3] += frustrum[2]
    >>> frustrum[5] += frustrum[4]
    >>> M = clip_matrix(*frustrum, perspective=False)
    >>> numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0])
    array([-1., -1., -1.,  1.])
    >>> numpy.dot(M, [frustrum[1], frustrum[3], frustrum[5], 1.0])
    array([ 1.,  1.,  1.,  1.])
    >>> M = clip_matrix(*frustrum, perspective=True)
    >>> v = numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0])
    >>> v / v[3]
    array([-1., -1., -1.,  1.])
    >>> v = numpy.dot(M, [frustrum[1], frustrum[3], frustrum[4], 1.0])
    >>> v / v[3]
    array([ 1.,  1., -1.,  1.])

    "
                :arguments 
                  ( ("left" variable nil (reparse-symbol function_parameters) [21372 21376])
                    ("right" variable nil (reparse-symbol function_parameters) [21378 21383])
                    ("bottom" variable nil (reparse-symbol function_parameters) [21385 21391])
                    ("top" variable nil (reparse-symbol function_parameters) [21393 21396])
                    ("near" variable nil (reparse-symbol function_parameters) [21398 21402])
                    ("far" variable nil (reparse-symbol function_parameters) [21404 21407])
                    ("perspective" variable nil (reparse-symbol function_parameters) [21409 21420]))                  )
                nil [21356 23495])
            ("shear_matrix" function
               (:documentation "Return matrix to shear by angle along direction vector on shear plane.

    The shear plane is defined by a point and normal vector. The direction
    vector must be orthogonal to the plane's normal vector.

    A point P is transformed by the shear matrix into P\" such that
    the vector P-P\" is parallel to the direction vector and its extent is
    given by the angle of P-P'-P\", where P' is the orthogonal projection
    of P onto the shear plane.

    >>> angle = (random.random() - 0.5) * 4*math.pi
    >>> direct = numpy.random.random(3) - 0.5
    >>> point = numpy.random.random(3) - 0.5
    >>> normal = numpy.cross(direct, numpy.random.random(3))
    >>> S = shear_matrix(angle, direct, point, normal)
    >>> numpy.allclose(1.0, numpy.linalg.det(S))
    True

    "
                :arguments 
                  ( ("angle" variable nil (reparse-symbol function_parameters) [23514 23519])
                    ("direction" variable nil (reparse-symbol function_parameters) [23521 23530])
                    ("point" variable nil (reparse-symbol function_parameters) [23532 23537])
                    ("normal" variable nil (reparse-symbol function_parameters) [23539 23545]))                  )
                nil [23497 24728])
            ("shear_from_matrix" function
               (:documentation "Return shear angle, direction and plane from shear matrix.

    >>> angle = (random.random() - 0.5) * 4*math.pi
    >>> direct = numpy.random.random(3) - 0.5
    >>> point = numpy.random.random(3) - 0.5
    >>> normal = numpy.cross(direct, numpy.random.random(3))
    >>> S0 = shear_matrix(angle, direct, point, normal)
    >>> angle, direct, point, normal = shear_from_matrix(S0)
    >>> S1 = shear_matrix(angle, direct, point, normal)
    >>> is_same_transform(S0, S1)
    True

    "
                :arguments 
                  ( ("matrix" variable nil (reparse-symbol function_parameters) [24752 24758]))                  )
                nil [24730 26385])
            ("decompose_matrix" function
               (:documentation "Return sequence of transformations from transformation matrix.

    matrix : array_like
        Non-degenerative homogeneous transformation matrix

    Return tuple of:
        scale : vector of 3 scaling factors
        shear : list of shear factors for x-y, x-z, y-z axes
        angles : list of Euler angles about static x, y, z axes
        translate : translation vector along x, y, z axes
        perspective : perspective partition of matrix

    Raise ValueError if matrix is of wrong type or degenerative.

    >>> T0 = translation_matrix((1, 2, 3))
    >>> scale, shear, angles, trans, persp = decompose_matrix(T0)
    >>> T1 = translation_matrix(trans)
    >>> numpy.allclose(T0, T1)
    True
    >>> S = scale_matrix(0.123)
    >>> scale, shear, angles, trans, persp = decompose_matrix(S)
    >>> scale[0]
    0.123
    >>> R0 = euler_matrix(1, 2, 3)
    >>> scale, shear, angles, trans, persp = decompose_matrix(R0)
    >>> R1 = euler_matrix(*angles)
    >>> numpy.allclose(R0, R1)
    True

    "
                :arguments 
                  ( ("matrix" variable nil (reparse-symbol function_parameters) [26408 26414]))                  )
                nil [26387 29007])
            ("compose_matrix" function
               (:documentation "Return transformation matrix from sequence of transformations.

    This is the inverse of the decompose_matrix function.

    Sequence of transformations:
        scale : vector of 3 scaling factors
        shear : list of shear factors for x-y, x-z, y-z axes
        angles : list of Euler angles about static x, y, z axes
        translate : translation vector along x, y, z axes
        perspective : perspective partition of matrix

    >>> scale = numpy.random.random(3) - 0.5
    >>> shear = numpy.random.random(3) - 0.5
    >>> angles = (numpy.random.random(3) - 0.5) * (2*math.pi)
    >>> trans = numpy.random.random(3) - 0.5
    >>> persp = numpy.random.random(4) - 0.5
    >>> M0 = compose_matrix(scale, shear, angles, trans, persp)
    >>> result = decompose_matrix(M0)
    >>> M1 = compose_matrix(*result)
    >>> is_same_transform(M0, M1)
    True

    "
                :arguments 
                  ( ("scale" variable nil (reparse-symbol function_parameters) [29028 29033])
                    ("shear" variable nil (reparse-symbol function_parameters) [29040 29045])
                    ("angles" variable nil (reparse-symbol function_parameters) [29052 29058])
                    ("translate" variable nil (reparse-symbol function_parameters) [29065 29074])
                    ("perspective" variable nil (reparse-symbol function_parameters) [29100 29111]))                  )
                nil [29009 30749])
            ("orthogonalization_matrix" function
               (:documentation "Return orthogonalization matrix for crystallographic cell coordinates.

    Angles are expected in degrees.

    The de-orthogonalization matrix is the inverse.

    >>> O = orthogonalization_matrix((10., 10., 10.), (90., 90., 90.))
    >>> numpy.allclose(O[:3, :3], numpy.identity(3, float) * 10)
    True
    >>> O = orthogonalization_matrix([9.8, 12.0, 15.5], [87.2, 80.7, 69.7])
    >>> numpy.allclose(numpy.sum(O), 43.063229)
    True

    "
                :arguments 
                  ( ("lengths" variable nil (reparse-symbol function_parameters) [30780 30787])
                    ("angles" variable nil (reparse-symbol function_parameters) [30789 30795]))                  )
                nil [30751 31727])
            ("superimposition_matrix" function
               (:documentation "Return matrix to transform given vector set into second vector set.

    v0 and v1 are shape (3, \\*) or (4, \\*) arrays of at least 3 vectors.

    If usesvd is True, the weighted sum of squared deviations (RMSD) is
    minimized according to the algorithm by W. Kabsch [8]. Otherwise the
    quaternion based algorithm by B. Horn [9] is used (slower when using
    this Python implementation).

    The returned matrix performs rotation, translation and uniform scaling
    (if specified).

    >>> v0 = numpy.random.rand(3, 10)
    >>> M = superimposition_matrix(v0, v0)
    >>> numpy.allclose(M, numpy.identity(4))
    True
    >>> R = random_rotation_matrix(numpy.random.random(3))
    >>> v0 = ((1,0,0), (0,1,0), (0,0,1), (1,1,1))
    >>> v1 = numpy.dot(R, v0)
    >>> M = superimposition_matrix(v0, v1)
    >>> numpy.allclose(v1, numpy.dot(M, v0))
    True
    >>> v0 = (numpy.random.rand(4, 100) - 0.5) * 20.0
    >>> v0[3] = 1.0
    >>> v1 = numpy.dot(R, v0)
    >>> M = superimposition_matrix(v0, v1)
    >>> numpy.allclose(v1, numpy.dot(M, v0))
    True
    >>> S = scale_matrix(random.random())
    >>> T = translation_matrix(numpy.random.random(3)-0.5)
    >>> M = concatenate_matrices(T, R, S)
    >>> v1 = numpy.dot(M, v0)
    >>> v0[:3] += numpy.random.normal(0.0, 1e-9, 300).reshape(3, -1)
    >>> M = superimposition_matrix(v0, v1, scaling=True)
    >>> numpy.allclose(v1, numpy.dot(M, v0))
    True
    >>> M = superimposition_matrix(v0, v1, scaling=True, usesvd=False)
    >>> numpy.allclose(v1, numpy.dot(M, v0))
    True
    >>> v = numpy.empty((4, 100, 3), dtype=numpy.float64)
    >>> v[:, :, 0] = v0
    >>> M = superimposition_matrix(v0, v1, scaling=True, usesvd=False)
    >>> numpy.allclose(v1, numpy.dot(M, v[:, :, 0]))
    True

    "
                :arguments 
                  ( ("v0" variable nil (reparse-symbol function_parameters) [31756 31758])
                    ("v1" variable nil (reparse-symbol function_parameters) [31760 31762])
                    ("scaling" variable nil (reparse-symbol function_parameters) [31764 31771])
                    ("usesvd" variable nil (reparse-symbol function_parameters) [31779 31785]))                  )
                nil [31729 35504])
            ("euler_matrix" function
               (:documentation "Return homogeneous rotation matrix from Euler angles and axis sequence.

    ai, aj, ak : Euler's roll, pitch and yaw angles
    axes : One of 24 axis sequences as string or encoded tuple

    >>> R = euler_matrix(1, 2, 3, 'syxz')
    >>> numpy.allclose(numpy.sum(R[0]), -1.34786452)
    True
    >>> R = euler_matrix(1, 2, 3, (0, 1, 0, 1))
    >>> numpy.allclose(numpy.sum(R[0]), -0.383436184)
    True
    >>> ai, aj, ak = (4.0*math.pi) * (numpy.random.random(3) - 0.5)
    >>> for axes in _AXES2TUPLE.keys():
    ...    R = euler_matrix(ai, aj, ak, axes)
    >>> for axes in _TUPLE2AXES.keys():
    ...    R = euler_matrix(ai, aj, ak, axes)

    "
                :arguments 
                  ( ("ai" variable nil (reparse-symbol function_parameters) [35523 35525])
                    ("aj" variable nil (reparse-symbol function_parameters) [35527 35529])
                    ("ak" variable nil (reparse-symbol function_parameters) [35531 35533])
                    ("axes" variable nil (reparse-symbol function_parameters) [35535 35539]))                  )
                nil [35506 37264])
            ("euler_from_matrix" function
               (:documentation "Return Euler angles from rotation matrix for specified axis sequence.

    axes : One of 24 axis sequences as string or encoded tuple

    Note that many Euler angle triplets can describe one matrix.

    >>> R0 = euler_matrix(1, 2, 3, 'syxz')
    >>> al, be, ga = euler_from_matrix(R0, 'syxz')
    >>> R1 = euler_matrix(al, be, ga, 'syxz')
    >>> numpy.allclose(R0, R1)
    True
    >>> angles = (4.0*math.pi) * (numpy.random.random(3) - 0.5)
    >>> for axes in _AXES2TUPLE.keys():
    ...    R0 = euler_matrix(axes=axes, *angles)
    ...    R1 = euler_matrix(axes=axes, *euler_from_matrix(R0, axes))
    ...    if not numpy.allclose(R0, R1): print axes, \"failed\"

    "
                :arguments 
                  ( ("matrix" variable nil (reparse-symbol function_parameters) [37288 37294])
                    ("axes" variable nil (reparse-symbol function_parameters) [37296 37300]))                  )
                nil [37266 39185])
            ("euler_from_quaternion" function
               (:documentation "Return Euler angles from quaternion for specified axis sequence.

    >>> angles = euler_from_quaternion([0.06146124, 0, 0, 0.99810947])
    >>> numpy.allclose(angles, [0.123, 0, 0])
    True

    "
                :arguments 
                  ( ("quaternion" variable nil (reparse-symbol function_parameters) [39213 39223])
                    ("axes" variable nil (reparse-symbol function_parameters) [39225 39229]))                  )
                nil [39187 39513])
            ("quaternion_from_euler" function
               (:documentation "Return quaternion from Euler angles and axis sequence.

    ai, aj, ak : Euler's roll, pitch and yaw angles
    axes : One of 24 axis sequences as string or encoded tuple

    >>> q = quaternion_from_euler(1, 2, 3, 'ryxz')
    >>> numpy.allclose(q, [0.310622, -0.718287, 0.444435, 0.435953])
    True

    "
                :arguments 
                  ( ("ai" variable nil (reparse-symbol function_parameters) [39541 39543])
                    ("aj" variable nil (reparse-symbol function_parameters) [39545 39547])
                    ("ak" variable nil (reparse-symbol function_parameters) [39549 39551])
                    ("axes" variable nil (reparse-symbol function_parameters) [39553 39557]))                  )
                nil [39515 40925])
            ("quaternion_about_axis" function
               (:documentation "Return quaternion for rotation about axis.

    >>> q = quaternion_about_axis(0.123, (1, 0, 0))
    >>> numpy.allclose(q, [0.06146124, 0, 0, 0.99810947])
    True

    "
                :arguments 
                  ( ("angle" variable nil (reparse-symbol function_parameters) [40953 40958])
                    ("axis" variable nil (reparse-symbol function_parameters) [40960 40964]))                  )
                nil [40927 41399])
            ("quaternion_matrix" function
               (:documentation "Return homogeneous rotation matrix from quaternion.

    >>> R = quaternion_matrix([0.06146124, 0, 0, 0.99810947])
    >>> numpy.allclose(R, rotation_matrix(0.123, (1, 0, 0)))
    True

    "
                :arguments 
                  ( ("quaternion" variable nil (reparse-symbol function_parameters) [41423 41433]))                  )
                nil [41401 42204])
            ("quaternion_from_matrix" function
               (:documentation "Return quaternion from rotation matrix.

    >>> R = rotation_matrix(0.123, (1, 2, 3))
    >>> q = quaternion_from_matrix(R)
    >>> numpy.allclose(q, [0.0164262, 0.0328524, 0.0492786, 0.9981095])
    True

    "
                :arguments 
                  ( ("matrix" variable nil (reparse-symbol function_parameters) [42233 42239]))                  )
                nil [42206 43115])
            ("quaternion_multiply" function
               (:documentation "Return multiplication of two quaternions.

    >>> q = quaternion_multiply([1, -2, 3, 4], [-5, 6, 7, 8])
    >>> numpy.allclose(q, [-44, -14, 48, 28])
    True

    "
                :arguments 
                  ( ("quaternion1" variable nil (reparse-symbol function_parameters) [43141 43152])
                    ("quaternion0" variable nil (reparse-symbol function_parameters) [43154 43165]))                  )
                nil [43117 43617])
            ("quaternion_conjugate" function
               (:documentation "Return conjugate of quaternion.

    >>> q0 = random_quaternion()
    >>> q1 = quaternion_conjugate(q0)
    >>> q1[3] == q0[3] and all(q1[:3] == -q0[:3])
    True

    "
                :arguments 
                  ( ("quaternion" variable nil (reparse-symbol function_parameters) [43644 43654]))                  )
                nil [43619 43969])
            ("quaternion_inverse" function
               (:documentation "Return inverse of quaternion.

    >>> q0 = random_quaternion()
    >>> q1 = quaternion_inverse(q0)
    >>> numpy.allclose(quaternion_multiply(q0, q1), [0, 0, 0, 1])
    True

    "
                :arguments 
                  ( ("quaternion" variable nil (reparse-symbol function_parameters) [43994 44004]))                  )
                nil [43971 44278])
            ("quaternion_slerp" function
               (:documentation "Return spherical linear interpolation between two quaternions.

    >>> q0 = random_quaternion()
    >>> q1 = random_quaternion()
    >>> q = quaternion_slerp(q0, q1, 0.0)
    >>> numpy.allclose(q, q0)
    True
    >>> q = quaternion_slerp(q0, q1, 1.0, 1)
    >>> numpy.allclose(q, q1)
    True
    >>> q = quaternion_slerp(q0, q1, 0.5)
    >>> angle = math.acos(numpy.dot(q0, q))
    >>> numpy.allclose(2.0, math.acos(numpy.dot(q0, q1)) / angle) or \\
        numpy.allclose(2.0, math.acos(-numpy.dot(q0, q1)) / angle)
    True

    "
                :arguments 
                  ( ("quat0" variable nil (reparse-symbol function_parameters) [44301 44306])
                    ("quat1" variable nil (reparse-symbol function_parameters) [44308 44313])
                    ("fraction" variable nil (reparse-symbol function_parameters) [44315 44323])
                    ("spin" variable nil (reparse-symbol function_parameters) [44325 44329])
                    ("shortestpath" variable nil (reparse-symbol function_parameters) [44333 44345]))                  )
                nil [44280 45459])
            ("random_quaternion" function
               (:documentation "Return uniform random unit quaternion.

    rand: array like or None
        Three independent random variables that are uniformly distributed
        between 0 and 1.

    >>> q = random_quaternion()
    >>> numpy.allclose(1.0, vector_norm(q))
    True
    >>> q = random_quaternion(numpy.random.random(3))
    >>> q.shape
    (4,)

    "
                :arguments 
                  ( ("rand" variable nil (reparse-symbol function_parameters) [45483 45487]))                  )
                nil [45461 46265])
            ("random_rotation_matrix" function
               (:documentation "Return uniform random rotation matrix.

    rnd: array like
        Three independent random variables that are uniformly distributed
        between 0 and 1 for each returned quaternion.

    >>> R = random_rotation_matrix()
    >>> numpy.allclose(numpy.dot(R.T, R), numpy.identity(4))
    True

    "
                :arguments 
                  ( ("rand" variable nil (reparse-symbol function_parameters) [46294 46298]))                  )
                nil [46267 46672])
            ("Arcball" type
               (:documentation "Virtual Trackball Control.

    >>> ball = Arcball()
    >>> ball = Arcball(initial=numpy.identity(4))
    >>> ball.place([320, 320], 320)
    >>> ball.down([500, 250])
    >>> ball.drag([475, 275])
    >>> R = ball.matrix()
    >>> numpy.allclose(numpy.sum(R), 3.90583455)
    True
    >>> ball = Arcball(initial=[0, 0, 0, 1])
    >>> ball.place([320, 320], 320)
    >>> ball.setaxes([1,1,0], [-1, 1, 0])
    >>> ball.setconstrain(True)
    >>> ball.down([400, 200])
    >>> ball.drag([200, 400])
    >>> R = ball.matrix()
    >>> numpy.allclose(numpy.sum(R), 0.2055924)
    True
    >>> ball.next()

    "
                :superclasses ("object")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("\"\"\"Initialize virtual trackball control.

        initial : quaternion or rotation matrix

        \"\"\"" code nil (reparse-symbol indented_block_body) [47361 47463])
                            ("self" variable nil (reparse-symbol indented_block_body) [47472 47489])
                            ("self" variable nil (reparse-symbol indented_block_body) [47498 47515])
                            ("self" variable nil (reparse-symbol indented_block_body) [47524 47542])
                            ("self" variable nil (reparse-symbol indented_block_body) [47551 47576])
                            ("self" variable nil (reparse-symbol indented_block_body) [47585 47642])
                            ("self" variable nil (reparse-symbol indented_block_body) [47651 47674])
                            ("if" code nil (reparse-symbol indented_block_body) [47684 48174])
                            ("self" variable nil (reparse-symbol indented_block_body) [48183 48220]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [47332 47336])
                            ("initial" variable nil (reparse-symbol function_parameters) [47338 47345]))                          
                        :documentation "Initialize virtual trackball control.

        initial : quaternion or rotation matrix

        "
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [47319 48221])
                    ("place" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [48236 48240])
                            ("center" variable nil (reparse-symbol function_parameters) [48242 48248])
                            ("radius" variable nil (reparse-symbol function_parameters) [48250 48256]))                          
                        :documentation "Place Arcball, e.g. when window size changes.

        center : sequence[2]
            Window coordinates of trackball center.
        radius : float
            Radius of trackball in window coordinates.

        ")
                        (reparse-symbol indented_block_body) [48226 48598])
                    ("setaxes" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [48615 48619])
                            ("axes" variable nil (reparse-symbol function_parameters) [48621 48626]))                          
                        :documentation "Set axes to constrain rotations.")
                        (reparse-symbol indented_block_body) [48603 48807])
                    ("setconstrain" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [48829 48833])
                            ("constrain" variable nil (reparse-symbol function_parameters) [48835 48844]))                          
                        :documentation "Set state of constrain to axis mode.")
                        (reparse-symbol indented_block_body) [48812 48942])
                    ("getconstrain" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [48964 48968]))                          
                        :documentation "Return state of constrain to axis mode.")
                        (reparse-symbol indented_block_body) [48947 49056])
                    ("down" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [49070 49074])
                            ("point" variable nil (reparse-symbol function_parameters) [49076 49081]))                          
                        :documentation "Set initial cursor window coordinates and pick constrain-axis.")
                        (reparse-symbol indented_block_body) [49061 49534])
                    ("drag" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [49548 49552])
                            ("point" variable nil (reparse-symbol function_parameters) [49554 49559]))                          
                        :documentation "Update current cursor window coordinates.")
                        (reparse-symbol indented_block_body) [49539 50078])
                    ("next" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [50092 50096])
                            ("acceleration" variable nil (reparse-symbol function_parameters) [50098 50110]))                          
                        :documentation "Continue rotation in direction of last drag.")
                        (reparse-symbol indented_block_body) [50083 50301])
                    ("matrix" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [50317 50321]))                          
                        :documentation "Return homogeneous rotation matrix.")
                        (reparse-symbol indented_block_body) [50306 50419]))                  
                :type "class")
                nil [46674 50419])
            ("arcball_map_to_sphere" function
               (:documentation "Return unit sphere coordinates from window coordinates."
                :arguments 
                  ( ("point" variable nil (reparse-symbol function_parameters) [50447 50452])
                    ("center" variable nil (reparse-symbol function_parameters) [50454 50460])
                    ("radius" variable nil (reparse-symbol function_parameters) [50462 50468]))                  )
                nil [50421 50851])
            ("arcball_constrain_to_axis" function
               (:documentation "Return sphere point perpendicular to axis."
                :arguments 
                  ( ("point" variable nil (reparse-symbol function_parameters) [50883 50888])
                    ("axis" variable nil (reparse-symbol function_parameters) [50890 50894]))                  )
                nil [50853 51344])
            ("arcball_nearest_axis" function
               (:documentation "Return axis, which arc is nearest to point."
                :arguments 
                  ( ("point" variable nil (reparse-symbol function_parameters) [51371 51376])
                    ("axes" variable nil (reparse-symbol function_parameters) [51378 51382]))                  )
                nil [51346 51711])
            ("_EPS" code nil nil [51769 51804])
            ("_NEXT_AXIS" variable nil nil [51840 51865])
            ("_AXES2TUPLE" variable nil nil [51942 52517])
            ("_TUPLE2AXES" variable nil nil [52519 52577])
            ("vector_norm" function
               (:documentation "Return length, i.e. eucledian norm, of ndarray along axis.

    >>> v = numpy.random.random(3)
    >>> n = vector_norm(v)
    >>> numpy.allclose(n, numpy.linalg.norm(v))
    True
    >>> v = numpy.random.rand(6, 5, 3)
    >>> n = vector_norm(v, axis=-1)
    >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=2)))
    True
    >>> n = vector_norm(v, axis=1)
    >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1)))
    True
    >>> v = numpy.random.rand(5, 4, 3)
    >>> n = numpy.empty((5, 3), dtype=numpy.float64)
    >>> vector_norm(v, axis=1, out=n)
    >>> numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1)))
    True
    >>> vector_norm([])
    0.0
    >>> vector_norm([1.0])
    1.0

    "
                :arguments 
                  ( ("data" variable nil (reparse-symbol function_parameters) [52615 52619])
                    ("axis" variable nil (reparse-symbol function_parameters) [52621 52625])
                    ("out" variable nil (reparse-symbol function_parameters) [52632 52635]))                  )
                nil [52599 53750])
            ("unit_vector" function
               (:documentation "Return ndarray normalized by length, i.e. eucledian norm, along axis.

    >>> v0 = numpy.random.random(3)
    >>> v1 = unit_vector(v0)
    >>> numpy.allclose(v1, v0 / numpy.linalg.norm(v0))
    True
    >>> v0 = numpy.random.rand(5, 4, 3)
    >>> v1 = unit_vector(v0, axis=-1)
    >>> v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=2)), 2)
    >>> numpy.allclose(v1, v2)
    True
    >>> v1 = unit_vector(v0, axis=1)
    >>> v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=1)), 1)
    >>> numpy.allclose(v1, v2)
    True
    >>> v1 = numpy.empty((5, 4, 3), dtype=numpy.float64)
    >>> unit_vector(v0, axis=1, out=v1)
    >>> numpy.allclose(v1, v2)
    True
    >>> list(unit_vector([]))
    []
    >>> list(unit_vector([1.0]))
    [1.0]

    "
                :arguments 
                  ( ("data" variable nil (reparse-symbol function_parameters) [53768 53772])
                    ("axis" variable nil (reparse-symbol function_parameters) [53774 53778])
                    ("out" variable nil (reparse-symbol function_parameters) [53785 53788]))                  )
                nil [53752 55097])
            ("random_vector" function
               (:documentation "Return array of random doubles in the half-open interval [0.0, 1.0).

    >>> v = random_vector(10000)
    >>> numpy.all(v >= 0.0) and numpy.all(v < 1.0)
    True
    >>> v0 = random_vector(10)
    >>> v1 = random_vector(10)
    >>> numpy.any(v0 == v1)
    False

    "
                :arguments 
                  ( ("size" variable nil (reparse-symbol function_parameters) [55117 55121]))                  )
                nil [55099 55440])
            ("inverse_matrix" function
               (:documentation "Return inverse of square transformation matrix.

    >>> M0 = random_rotation_matrix()
    >>> M1 = inverse_matrix(M0.T)
    >>> numpy.allclose(M1, numpy.linalg.inv(M0.T))
    True
    >>> for size in range(1, 7):
    ...     M0 = numpy.random.rand(size, size)
    ...     M1 = inverse_matrix(M0)
    ...     if not numpy.allclose(M1, numpy.linalg.inv(M0)): print size

    "
                :arguments 
                  ( ("matrix" variable nil (reparse-symbol function_parameters) [55461 55467]))                  )
                nil [55442 55891])
            ("concatenate_matrices" function
               (:documentation "Return concatenation of series of transformation matrices.

    >>> M = numpy.random.rand(16).reshape((4, 4)) - 0.5
    >>> numpy.allclose(M, concatenate_matrices(M))
    True
    >>> numpy.allclose(numpy.dot(M, M.T), concatenate_matrices(M, M.T))
    True

    "
                :arguments 
                  ( ("matrices" variable nil (reparse-symbol function_parameters) [55918 55927]))                  )
                nil [55893 56293])
            ("is_same_transform" function
               (:documentation "Return True if two matrices perform same transformation.

    >>> is_same_transform(numpy.identity(4), numpy.identity(4))
    True
    >>> is_same_transform(numpy.identity(4), random_rotation_matrix())
    False

    "
                :arguments 
                  ( ("matrix0" variable nil (reparse-symbol function_parameters) [56317 56324])
                    ("matrix1" variable nil (reparse-symbol function_parameters) [56326 56333]))                  )
                nil [56295 56800])
            ("_import_module" function
               (:documentation "Try import all public attributes from module into global namespace.

    Existing attributes with name clashes are renamed with prefix.
    Attributes starting with underscore are ignored by default.

    Return True on successful import.

    "
                :arguments 
                  ( ("module_name" variable nil (reparse-symbol function_parameters) [56821 56832])
                    ("warn" variable nil (reparse-symbol function_parameters) [56834 56838])
                    ("prefix" variable nil (reparse-symbol function_parameters) [56845 56851])
                    ("ignore" variable nil (reparse-symbol function_parameters) [56860 56866]))                  )
                nil [56802 57702]))          
      :file "transformations.py"
      :pointmax 57702
      :fsize 57701
      :lastmodtime '(24684 61264 39231 436000)
      :unmatched-syntax nil)
    (semanticdb-table "semanticdb-table"
      :major-mode python-mode
      :tags 
        '( ("future.utils" include nil nil [1 35])
            ("Configuration" type
               (:superclasses ("object")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("self" variable nil (reparse-symbol indented_block_body) [110 130]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [84 88])
                            ("config" variable nil (reparse-symbol function_parameters) [90 96]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [71 131])
                    ("update" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [147 151])
                            ("config" variable nil (reparse-symbol function_parameters) [153 159]))                          )
                        (reparse-symbol indented_block_body) [136 298])
                    ("__getitem__" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [319 323])
                            ("key" variable nil (reparse-symbol function_parameters) [325 328]))                          )
                        (reparse-symbol indented_block_body) [303 363])
                    ("__setitem__" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [384 388])
                            ("key" variable nil (reparse-symbol function_parameters) [390 393])
                            ("value" variable nil (reparse-symbol function_parameters) [395 400]))                          )
                        (reparse-symbol indented_block_body) [368 436])
                    ("keys" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [450 454]))                          )
                        (reparse-symbol indented_block_body) [441 491])
                    ("get" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [512 516])
                            ("key" variable nil (reparse-symbol function_parameters) [518 521]))                          )
                        (reparse-symbol indented_block_body) [504 923])
                    ("set" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [936 940])
                            ("key_value_list" variable nil (reparse-symbol function_parameters) [942 956]))                          )
                        (reparse-symbol indented_block_body) [928 1437]))                  
                :type "class")
                nil [37 1437])
            ("if" code nil nil [1438 1799]))          
      :file "configuration.py"
      :pointmax 1804
      :fsize 1803
      :lastmodtime '(24684 61264 35231 450000)
      :unmatched-syntax nil))
  :file "!home!xli4217!Dropbox!postdoc!Research!TRI!project_src!stl_risk_aware_ioc!external_libs!nuscenes_env!utils!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
